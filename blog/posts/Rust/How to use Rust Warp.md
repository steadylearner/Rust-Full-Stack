<!--
    Post{
        subtitle: "Learn how to make a web project with Rust",
        image: "post/web/how-to-use-rust-warp.png",
        image_decription: "Image made with CSS by Steadylearner",
        tags: "How Rust Warp use",
    }
-->

<!-- Link -->

[Steadylearner]: https://www.steadylearner.com
[Rust Website]: https://www.rust-lang.org/
[Learn Rust]: https://doc.rust-lang.org/book/

[Rust async]: https://github.com/steadylearner/Rust-Full-Stack/tree/master/async

[cargo edit]: https://github.com/killercup/cargo-edit

[React Rust]: https://github.com/steadylearner/Rust-Full-Stack/tree/master/React_Rust

[Rust Rocket]: https://rocket.rs/
[Rocket Getting Started]: https://rocket.rs/v0.4/guide/getting-started
[Rocket JSON Example]: https://github.com/SergioBenitez/Rocket/tree/master/examples/json
[Redirect]: https://api.rocket.rs/v0.4/rocket/response/struct.Redirect.html
[Tera]: https://tera.netlify.com/
[Rocket Tera example]: https://github.com/SergioBenitez/Rocket/tree/master/examples/tera_templates

[CORS]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS
[OPTIONS]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/OPTIONS
[Rocket CORS]: https://github.com/lawliet89/rocket_cors
[Rocket CORS examples]: https://github.com/lawliet89/rocket_cors/tree/master/examples
[Rocket CORS fairing example]: https://github.com/lawliet89/rocket_cors/blob/master/examples/fairing.rs
[Rocket CORS fairng test example]: https://github.com/lawliet89/rocket_cors/blob/master/tests/fairing.rs

[Rust Yew Examples]: https://github.com/yewstack/yew/tree/master/examples

[hyper]: https://github.com/hyperium/hyper

[Rust Dotenv]: https://crates.io/crates/dotenv
[Reqwest]: https://docs.rs/reqwest/0.9.18/reqwest/

[stdweb]: https://github.com/koute/stdweb

[YouTube API]: https://developers.google.com/youtube/v3/getting-started#before-you-start
[How to use YouTube API for developers]: https://www.google.com/search?q=how+to+use+youtube+api+for+developers

[Rust Full Stack]: https://github.com/steadylearner/Rust-Full-Stack
[JSON Webservice]: https://github.com/steadylearner/Rust-Full-Stack/tree/master/before/JSON_Webservice

[Rust Blog Example]: https://github.com/steadylearner/Rust-Full-Stack/tree/master/web/before/rust_blog

[CRA]: https://github.com/facebook/create-react-app

[protocol buffers]: https://developers.google.com/protocol-buffers/docs/overview
[Tonic]: https://github.com/hyperium/tonic
[Rust Postgresql]: https://github.com/sfackler/rust-postgres
[Rust Postgresql query]: https://docs.rs/postgres/0.15.2/postgres/struct.Connection.html#method.query
[Rust Postgresql execute]: https://docs.rs/postgres/0.15.2/postgres/struct.Connection.html#method.execute
[Tonic CRUD Example by Steadylearner]: https://github.com/steadylearner/Rust-Full-Stack/blob/master/grpc/user/proto/user/user.proto
[Official Tonic Guide]: https://github.com/hyperium/tonic/blob/master/tonic-examples/helloworld-tutorial.md
[gRPC Client]: https://github.com/uw-labs/bloomrpc

[How to install Postgresql]: https://www.digitalocean.com/community/tutorials/how-to-install-and-use-postgresql-on-ubuntu-18-04

[tonic-build]: https://github.com/hyperium/tonic/blob/master/tonic-build/README.md

[Rust uuid]: https://crates.io/crates/uuid
[chrono]: https://docs.rs/chrono/0.4.9/chrono/

[graphiql]: https://github.com/graphql/graphiql

[React Rust]: https://github.com/steadylearner/React-Rust
[React Router]: https://github.com/ReactTraining/react-router

[Warp]: https://github.com/seanmonstar/warp
[Warp official example]: https://github.com/seanmonstar/warp#example
[Warp official examples]: https://github.com/seanmonstar/warp/tree/master/examples
[Warp examples]: https://github.com/steadylearner/Rust-Full-Stack/tree/master/warp
[Warp documentation]: https://docs.rs/warp/0.2.1/warp/
[Warp database example]: https://github.com/steadylearner/Rust-Full-Stack/tree/master/warp/database/2.%20with_db_pool/src

[Rust async]: https://github.com/steadylearner/Rust-Full-Stack/tree/master/async

[tokio]: https://github.com/tokio-rs/tokio
[async std]: https://github.com/async-rs/async-std

[Express]: https://expressjs.com

[FP in Rust]: https://github.com/JasonShin/fp-core.rs
[Reading Rust function signatures]: https://hoverbear.org/blog/reading-rust-function-signatures/
[Real world Tacit programming part 1]: https://medium.com/@jesterxl/real-world-uses-of-tacit-programming-part-1-of-2-f2a0c3f9e00c
[Real world Tacit programming part 2]: https://medium.com/@jesterxl/real-world-uses-of-tacit-programming-part-2-of-2-6422da10dc47
[Rust closures are hard]: https://stevedonovan.github.io/rustifications/2018/08/18/rust-closures-are-hard.html

[microservices_with_docker]: https://github.com/steadylearner/Rust-Full-Stack/tree/master/microservices_with_docker

<!-- / -->

<!-- Steadylearner Post -->

[Rust blog posts]: https://www.steadylearner.com/blog/search/Rust
[How to install Rust]: https://www.steadylearner.com/blog/read/How-to-install-Rust
[Rust Chat App]: https://www.steadylearner.com/blog/read/How-to-start-Rust-Chat-App
[Rust Yew Frontend]: https://github.com/yewstack/yew
[Yew Counter]: https://www.steadylearner.com/yew_counter
[How to use Rust Yew]: https://www.steadylearner.com/blog/read/How-to-use-Rust-Yew
[How to deploy Rust Web App]: https://www.steadylearner.com/blog/read/How-to-deploy-Rust-Web-App
[How to start Rust Chat App]: https://www.steadylearner.com/blog/read/How-to-start-Rust-Chat-App
[Fullstack Rust with Yew]: https://www.steadylearner.com/blog/read/Fullstack-Rust-with-Yew
[How to use NPM packages with Rust Frontend]: https://www.steadylearner.com/blog/read/How-to-use-NPM-packages-with-Rust-Frontend
[How to use markdown with code snippets in Rust Yew Frontend]: https://www.steadylearner.com/blog/read/How-to-use-markdown-with-code-snippets-in-Rust-Yew-Frontend
[How to modulize your Rust Frontend]: https://www.steadylearner.com/blog/read/How-to-modulize-your-Rust-Frontend
[How to write Full Stack Rust Code]: https://www.steadylearner.com/blog/read/How-to-write-Full-Stack-Rust-code
[How to use a modal in Rust]: https://www.steadylearner.com/blog/read/How-to-use-a-modal-in-Rust
[How to use routers in Rust Frontend]: https://www.steadylearner.com/blog/read/How-to-use-routers-in-Rust-Frontend
[How to serve static files with Rust]: https://www.steadylearner.com/blog/read/How-to-serve-static-files-with-Rust
[How to use a single page app wtih Rust]: https://www.steadylearner.com/blog/read/How-to-use-a-single-page-app-with-Rust
[How to use Rust Tera for undefined paths]: https://www.steadylearner.com/blog/read/How-to-use-Rust-Tera-for-undefined-paths
[How to make JSON Webservice with Rust and YouTube API]: https://www.steadylearner.com/blog/read/How-to-make-JSON-Webservice-with-Rust-and-YouTube-API
[How to use CORS and OPTIONS HTTP request with Rust Rocket]: https://www.steadylearner.com/blog/read/How-to-use-CORS-and-OPTIONS-HTTP-request-with-Rust-Rocket
[How to render a YouTube vlog with Rust Yew fetch API]: https://www.steadylearner.com/blog/read/How-to-render-a-YouTube-vlog-with-Rust-Yew-fetch-API

[How to use Python in JavaScript]: https://www.steadylearner.com/blog/read/How-to-use-Python-in-JavaScript
[How to use React Spring to animate your message]: https://medium.com/@steadylearner/how-to-use-react-spring-to-animate-your-message-2bd2a7e62a5a

[How to use Webpack with React]: https://www.steadylearner.com/blog/read/How-to-use-Webpack-with-React
[Actix]: https://github.com/actix/actix-web
[How to use Docker commands]: https://www.steadylearner.com/blog/read/How-to-use-Docker-commands
[How to use Docker with Rust]: https://www.steadylearner.com/blog/read/How-to-use-Docker-with-Rust
[How to use React with Rust Actix]: https://www.steadylearner.com/blog/read/How-to-use-React-with-Rust-Actix

<!-- / -->

<!-- Steadylearner Twitter and LinkedIn  -->

[Twitter]: https://twitter.com/steadylearner_p
[LinkedIn]: https://www.linkedin.com/in/steady-learner-3151b7164/
[GitHub]: https://github.com/steadylearner
[donate]: https://www.paypal.com/donate/?token=MYCfCk47O9tUW-WzxzrampApJJ3hTEweiG3XrGS_04X3y6NH5lMG2CQ9ZMibZEEKKCfX_0&country.x=BR&locale.x=BR

<!--  -->

In this post, we will learn how to use Rust [Warp]. We will start from [the current official example at GitHub][Warp official example]. Then, we will learn how to modulize it.

If you are already familiar with Rust and want to save your time, please clone the [Rust Full Stack] repository and refer to [warp][Warp examples] and [microservice example][microservices_with_docker] there.

```console
$git clone https://github.com/steadylearner/Rust-Full-Stack.git
```

Then, inside **warp** folder use these.

```console
$cd hello_world
$cargo run --release
```

If you want to build a full stack Rust app, you can also refer to [How to use Rust Yew] later for Rust frontend part. You can use its Fetch API and request data from Rust servers to render its pages.

<br />

<h2 class="red-white">[Prerequisite]</h2>

1. [How to install Rust]
2. [Warp documentation] and [Warp official examples]
3. [The article to help you find Futures, Serivces and Filters better](https://blog.twitter.com/engineering/en_us/a/2011/finagle-a-protocol-agnostic-rpc-system.html)
4. [FP in Rust]
5. [Reading Rust function signatures]
6. [Real world Tacit programming part 1] and [Real world Tacit programming part 2]
7. [Rust closures are hard]
8. [Rust Future crate](https://docs.rs/futures), [Future by Example](https://docs.rs/future-by-example/0.1.0/future_by_example/) and [Rust future and_then](https://docs.rs/futures/0.3.1/futures/future/trait.TryFutureExt.html#method.and_then)

---

I want you to install Rust first if you haven't yet. The blog post [How to install Rust] will help you. If necessary, visit [Rust Website] for more information.

In this post, I will assume that you are already familiar with Rust. If not, please [learn how to use it first][Learn Rust].

Before you read on this post, I hope you read [Warp documentation] and [Warp official examples] thoroughly. You can also use this command after you install the dependency later.

```console
$cargo doc -p warp --open
```

It will be helpful to give more time to read the [routing example from the author](https://github.com/seanmonstar/warp/blob/master/examples/routing.rs). You will see that the author use [Closures][Rust closures are hard] as a main API of the framework. I let several documentations to help you find how they work better.

[You can also find more about and_then.](https://www.google.com/search?&q=rust+and_then)

[If you want to learn more async programming with Rust, please refer to this.][Rust async]

**Hope you read all of them after you complete this post.**

<br />

<h2 class="blue">Table of Contents</h2>

1. Start with the official example
2. Refactor it
3. Make Routes to filter user requests
4. Build Handlers to respond to them
5. Link them to end the API with macro
6. Test it work with CURL and Rust
7. **Conclusion**

---

The structure of project for this post is opinionated.

I could find that Warp projects can be organized similar to [Express] ones. It won't be difficult to make it this way if you are already familiar with Rust module systems.

(I hope you also spend time to read [its documentation.](https://expressjs.com/en/starter/installing.html))

You will learn how to use [Warp] with this post.

You will also learn how to modulize your Rust app along with it. Then, you will be able to organize your Rust projects easily.

You can skip the first and second part if you are already familiar with Rust.

<br />

## 1. Start with the official example

We will make **our first Warp app** with the official example given by its author. We will use serveral comamnds and make some files.

First, use **$cargo new hello_world** to make a minimal Rust boilerplate. The **cargo** should have made **src/main.rs** and **Cargo.toml** file.

**$cargo c** if you are new to Rust to verify Rust is working well in your machine.

Then, include dependencies in your Rust project by pasting this from the author to **Cargo.toml**. (If you are familar with **JavaScript** and **NPM**, You can think it is similar to **package.json**).

```toml
tokio = { version = "0.2", features = ["macros"] }
warp = "0.2.1"
```

You can also consider [cargo edit] commands instead.

Then, copy and paste it to **main.rs**.

```rust
use warp::Filter; // 1.

#[tokio::main] // 2.
async fn main() {
    let hello = warp::path!("hello" / String) // 3.
        .map(|name| format!("Hello, {}!", name)); // 4.

    warp::serve(hello) // 5.
        .run(([0, 0, 0, 0], 8000)) // 6.
        .await;
}
```

Everything is ready. Use **$cargo run --release**. Then, read on this blog post instead of waiting it to complete.

(It did take about 17 minutes in my more than half ten year old laptop. Hope your machine is faster than this.)

When it completes, you can use CURL command below to verify the end point **/hello/String**.

```console
$curl 0.0.0.0:8000/hello/www.steadylearner.com // return "Hello, www.steadylearner.com"
```

I hope your fisrt Warp app worked.

The code used here is very simple. But, a little help to find how they work will be very useful.

**1.** If you read its documenation already, the author says this.

```console
The fundamental building block of warp is the Filter
they can be combined and composed to express rich requirements on requests.
```

Therefore, it is used for this minimal example to demonstrate how it works and you will see that later also.

**2.** Warp uses [tokio] as its async task runner behind the scenes. You won't have to care for it much to make the example work except "its alternative is [async std] and they are not that compatible currently".

If you want to learn more about async programming with Rust, please read [all the documenations at async folder][Rust async] in the [Rust Full Stack].

**3.** If you are new to Warp framework, it may be difficult to find what this do. You can think that "hello" is static path and **String** part is to show your intention to receive dynamic param and that should be only **String** type.

If you are familar with other web framework such as **Express**. You can compare it with **req**(request) part of it.

The difference is you express only what you want to allow and use with the API given by **Warp**. Compare it with **routes/hello_route.rs** later.

**4.** The Rust clsoure is used here.(If you are familar with **Express**, You can compare it with **res**(respond) part of it.)

You can see that you could use **name** variable here inside || to use **String** param we allowed before. Then, you could express what you want to do with this.

```rust
format!("Hello, {}!", name)
```

Compare it with the **handlers/hello_handler.rs** later.

If you are new to Rust, you may wonder how the closure work without typing the **variable, params, return value and function signature** etc here.

That is because Rust compiler infers types for them instead of you. If you read the documenations for that already, it will be easy to find how they work.

With the help of it, the API of Warp becomes very easy with clsoures and will be similar to use JavaScript arrow functions.

But, differnt from JavaScript, it is not easy to make the closures reusable through the entire project. Therefore, we will use **functions** and **macros** instead.

**5.** We already made a hello API and saved it to **hello** variable before and learnt how they were made. Let the **Warp** serve it with this.

**6.** [I prefer to use 0.0.0.0 instead of localhost and its alias 127.0.0.1](https://www.google.com/search?&q=why+use+0.0.0.0+instead+of+localhost) to [dockerize apps easily][How to use Docker with Rust].

I hope this brief explantion helped you.

**Please, read all the documentation given before at prerequisite.**

<br />

## 2. Refactor it

Previously, we could make the official Warp example work and learnt details of each part.

We will refactor the example by using functions instead of the closure used there. When you end the process, the whole project will be simialr to this.

```console
├── Cargo.toml
├── src
│   ├── api
│   │   ├── hello.rs
│   │   └── mod.rs
│   ├── handlers
│   │   ├── hello_handler.rs
│   │   └── mod.rs
│   ├── main.rs
│   ├── routes
│   │   ├── hello_route.rs
│   │   └── mod.rs
│   └── tests
│       ├── hello_test.rs
│       └── mod.rs
```

You can see that we will make various folders such as routes/, handlers/, api/, tests/ etc and files inside them.

You can see many **mod.rs** there. But, its contents will be very simple with **pub mod hello_route** etc. You can think them just as helpers to export other files inside each folder.

If you want more information about this, please refer to [How to modulize your Rust Frontend] or [Rust Yew frontend example](https://github.com/steadylearner/Rust-Full-Stack/tree/master/web/src).

(Rust wants you to be specific with everything and exporting and importing the modules also. If you find its module system difficult, first search what represents them. It will be **mod.rs** in each folder and **main.rs** or **lib.rs** in top level directory of your Rust project. **crate** will represent main.rs or lib.rs and will work as if they were publisehd **crate** or **similar to package in JavaScript**. **self** will be used to represent **main.rs** or **lib.rs itself** inside themselves and use modules imported in them. You may want to use **crate** keyword but it won't because it already used inside **extern crate somecrate** syntax. So many texts, but I let this to help you but it will be better to learn it with examples.)

So without those mod.rs files, what we need will be just these.

```console
├── src
│   ├── api
│   │   ├── hello.rs
│   ├── handlers
│   │   ├── hello_handler.rs
│   ├── main.rs
│   ├── routes
│   │   ├── hello_route.rs
│   └── tests
│       ├── hello_test.rs
```

We will first start with **main.rs**. It will help you to find the sturcture of the entire project better.

```rust
use warp::{self, Filter};

use console::Style;

mod routes; // 1.
mod handlers; // 2.
mod api; // 3.

use self::{
    routes::{
        hello_route,
    },
    handlers::{
        hello_handler
    },
};

// It will only work with $cargo test
// For example, $cargo test hello -- --nocapture
#[cfg(test)] mod tests;

#[tokio::main]
async fn main() {
    let target: String = "0.0.0.0:8000".parse().unwrap();
    let blue = Style::new()
        .blue();

    // 4.
    let end = hello!().with(warp::log("hello"));

    println!("\nRust Warp Server ready at {}", blue.apply_to(&target));
    println!("Use $curl 0.0.0.0:8000/hello/www.steadylearner.com to test the end point.");

    warp::serve(end).run(([0, 0, 0, 0], 8000)).await;
}
```

You can see that it is very simple because every parts of it are already modulized.

What we do first is to include folder(submodules) we will make with **mod** keyword. You can substitute it in your mind with this.

```md
Import folder and its rust files along with it in the same directory. I should have already made **mod.rs** to represent the folder and written **pub mod filename** to export Rust files in there to satisfy the Rust compiler.
```

**1.** routes/ will include what you want server to accept from the user request. We already know that we will only accept **"/hello/String** route. You can compare it with **req part of Express**.

**2.** handlers/ will inlcude what you want server to do with it. We already know that we will return the html(text) with **format!("Hello, {}!", name)** and name part will be **String** filterd by **hello_route** we will make.

This will be the payload of your project.

You will spend most of time later with databases and **models/** to use them. Refer to [Warp database example] if you want.

**3.** The macro **hello!** we will make will be usable in main.rs and tests/hello_test.rs by importing **api** folder with this.

This is maybe optional. But, [it will help you not to write the same code below](https://www.reddit.com/r/rust/comments/erx83j/warp_i_made_some_warp_web_framework_examples_i/) in **tests/** folder we will make.

```rust
let hello = hello_route::hello()
    .and_then(hello_handler::hello)
```

You may wonder why macro is used here when you can use **functions** etc.

This was the last solution that I thought but maybe the simplest one. It was not easy to type the code because some types used for them are **private**, **unstable** and **not allowed** by the compiler.

You may refer to [compare](https://github.com/steadylearner/Rust-Full-Stack/tree/master/warp/hello_world/src/compare) folder before you would find the better way.

**4.** The variable name **end** is used here because it will be used before you finally serve it with **warp::serve**.

You can refer to this from [Warp database example].

```rust
let post_api = list_posts!()
    .or(get_post!())
    .or(create_post!())
    .or(update_post!())
    .or(delete_post!());

let end = post_api.with(warp::log("post_api"));
```

Other parts are just to help you debug the app better.

<br />

## 3. Routes to filter user requests

We defined **mod routes** to import Rust files(**hello_route.rs**) in **routes** in the main.rs previously. But, we haven't made it yet.

So we will write it with some explanation. It will be similar to this.

```rust
// It is equal to use
// let hello = path!("hello" / String);
// in main.rs file.

use warp::{
    filters::BoxedFilter,
    Filter,
};

// 1. "hello"
fn path_prefix() -> BoxedFilter<()> {
    warp::path("hello")
        .boxed()
}

// 2. / String
pub fn hello() -> BoxedFilter<(String, )> {
    warp::get() // 3.
        .and(path_prefix()) // 4.
        .and(warp::path::param::<String>()) // 5.
        .boxed()
}
```

**1.** First, we extract **hello** prefix part to make it reusable.

This is not so meanigful here. But, it will be useful [when you want to use prefixes for REST api](https://github.com/steadylearner/Rust-Full-Stack/blob/master/microservices_with_docker/warp_client/src/routes/user_route.rs) such as **api/post/v1**, **api/user/v1** etc.

You may think what are **BoxedFilter<()>** and **.boxed()** here. Think them as a glue to help you chain other methods when they are used inside **and** API of Warp later in **2.**

**2.** This will be the payload of this file. You define what you want to **filter**(use) from the user requests here.

**3.** Receive(filter) only GET requests.
**4.** That starts with /hello prefix we made before.

**5.** "Warp, accept param with **String** type only."

You can see that it will be the argument of the function we will make in **route_hanlder** later.

[You can also use custom types such as Post, NewPost.](https://github.com/steadylearner/Rust-Full-Stack/blob/master/warp/database/2.%20with_db_pool/src/models/post.rs)

The code used here is self-explanatory. But, hope these explanations helped you.

<br />

## 4. Build Handlers to respond to them

In the previous part, we defined the route to filter user requests. We will define how to handle them by builidng **hello_handler.rs**

It will be similar to this.

```rust
use warp;

pub async fn hello(name: String) -> Result<impl warp::Reply, warp::Rejection> {
    let reply = format!("Hello, {}!", name);
    // println!("{}", &reply);
    Ok(warp::reply::html(reply))
}
```

The code used here is very simple.

Fisrt, the return type of handler functions will almost always be this.

```rust
Result<impl warp::Reply, warp::Rejection>
```

**Therefore, just copy and paste** after you read the documentation for [Reply](https://docs.rs/warp/0.1.0/warp/reply/index.html) and [Rejection](https://docs.rs/warp/0.1.0/warp/reject/struct.Rejection.html).

You must care for how to handle Rejection parts. But, it is not necessary for this simple example.

You can also see that the **String** param we filtered in **hello_route.rs** became the parameter of the function here.

Compare it with what we used before in the first part.

```rust
.map(|name| format!("Hello, {}!", name));
```

It is true that **Rust Closures** are much simpler to use and prototype your Warp app. Use them first in **main.rs**. Then, separate them to **routes** and **handlers** when you want to modulize it.

<br />

## 5. Link them to end the API with macro

With **routes/** and **handlers/**, your application logic is already complete. Define hello! macro inside **api/hello.rs** similar to this to link them.

```rust
#[macro_export]
macro_rules! hello {
    () => {
        hello_route::hello()
        .and_then(hello_handler::hello)
    }
}
```

With **#[macro_export]**, [the macros defined this way become globally available at crate level.](https://stackoverflow.com/questions/29068716/how-do-you-use-a-macro-from-inside-its-own-crate).

They will only work when the module including it is included at **main.rs** or **lib.rs** that represent your Rust project with **mod api**.

You can use the macros from **api** inside **main.rs** or **lib.rs** without using this.

```rust
use crate::{
    hello,
};
```

If you want to use it in other parts of your project such as [tests/hello_test.rs](https://github.com/steadylearner/Rust-Full-Stack/blob/master/warp/hello_world/src/tests/hello_test.rs). You should include the code above to make it work.

All the files to compile your first Warp projects are ready.

Use **$cargo c** to verify it will compile or not first. Then, use **cargo run --release** for production or **cargo run** to compile fast.

Hope you could make it.

<br />

## 6. Test it work with CURL and Rust

If you followed well the previous parts, your console should have showed these already after your project compiled.

```console
Rust Warp Server ready at 0.0.0.0:8000
Use $curl 0.0.0.0:8000/hello/www.steadylearner.com to test the end point.
```

First, use **$curl 0.0.0.0:8000/hello/www.steadylearner.com**. It will show the same result you could see in the first part.

**CURL** is very useful to test end points but there are problems.

**1.** We have to make the Warp server ready all the time first. Rust compiler will take up your time.
**2.** Then, you should find which CURL commands to use. That can be complicated.

Therefore, we will make Rust test functions to simplify and automate the process. We will build **tests/hello_test.rs** equivalent to the CURL command we used.

```rust
use warp::Filter;

use crate::{
    handlers::hello_handler,
    routes::hello_route,
    hello,
};

// $cargo test -- --nocapture if you want to use println! etc.

// or test just one function each time.
// For example, $cargo test hello and it passes.

#[cfg(test)]
mod tests {
    use super::*;

    // 1.
    #[tokio::test]
    async fn hello() {
        let res = warp::test::request() // 2.
            .method("GET")
            .path("/hello/www.steadylearner.com")
            .reply(&hello!()) // 3.
            .await;

        // 4.
        assert_eq!(res.status(), 200, "Should return 200 OK.");
        // 5.
        println!("{:#?}", res.body());
    }
}
```

The important points are these.

**1.** We already learnt **Warp** uses [tokio] to handle async computations. Therefore, the test runner will be also **#[tokio:test]**.

**2.** Build a specific client request to test before **.reply**. It won't be difficult to find what these do because the same thoughts are used again.

**3.** Define here how you will reply to the request here. We already made **hello!** API for this.

**4.** See the server return **OK** with it.

**5.** You can test the function with **$cargo test hello**.

You can also use -- --nocapture flag to show **stdout** parts. For example, test it again with **$cargo test hello -- --nocapture**.

With CURL and a test with Rust, you can verify your API easily whenever you modify files in **routes/** and **handlers/**.

If you are curious, you can also test the performance with [loadtest](https://github.com/steadylearner/Rust-Full-Stack/blob/master/warp/hello_world/loadtest.md).

That won't be slow and its memory usage is very low.(**4.62 Mb** in my Linux Ubuntu 18.04 machine.)

Test on your own with this command on Linux while your Warp server is ready in another console.

1. Use this to see all memory usages in your system.

```console
$ps -eo size,pid,user,command --sort -size | awk '{ hr=$1/1024; printf("%13.2f Mb ",hr) } { for ( x=4 ; x<=NF ; x++ ) { printf("%s ",$x) } print "" }' | cut -d "" -f2 | cut -d "-" -f1
```

2. You can also include **grep** and Linux pipe **|** to see only how much memory Warp needs.

```console
$ps -eo size,pid,user,command --sort -size | awk '{ hr=$1/1024; printf("%13.2f Mb ",hr) } { for ( x=4 ; x<=NF ; x++ ) { printf("%s ",$x) } print "" }' | cut -d "" -f2 | cut -d "-" -f1 | grep "hello_world"
```

[Refer to them to compare it with other web frameworks you use](https://github.com/steadylearner/Rust-Full-Stack/tree/master/React_Rust#golang).

<br />

## 7. Conclusion

I hope you made it all work and could learn how to use [Warp] with this post. If you want to learn it more, you can find more [Warp examples].

[You can Dockerize it](https://www.steadylearner.com/blog/read/How-to-use-Docker-with-Rust), use it with a [React single page app][React Rust], [database][Warp database example], [deploy them to AWS][Steadylearner] etc.

The post was about [Warp] but I hope **people could learn how to build web app with Rust also** more than that.

The web development with Rust is not mainstream yet. So it was not easy to invest time for it again and write blog posts to help others even though it is [much faster than most of other web frameworks][React Rust].

If you want the latest contents from Steadylearner, follow me at [Twitter], [GitHub].

You can also **star** [Rust Full Stack].

**Share it with others to help them find the repository better and start the Rust programming easily**.

You can also [donate] **to help this website persist** and **give more time for the author to write more blog posts**.

Do you need a Full Stack Developer? Contact me with [LinkedIn] or [Twitter] and I will help you.

I really want to find where to spend my skills.

**You can invite me to work for your company. I can help you with Rust, JavaScript, Python and Golang with Docker and AWS.**

**I want to let special thanks to the Rust community who could find values with my work to share my Rust learning.**

**Without them, I wouldn't have written this blog post and made the examples.**

(Rust will be used much more than before and have many opportunities this year. I want these blog posts could contribute to that.)

